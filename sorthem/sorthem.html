<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<title>Sorthem™</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="viewport" content="initial-scale=2.0"/>
<style type="text/css">
  body {background:#fff; color:#000; height:100vh; font-family:sans-serif,arial,helvetica }
  div,p,h1 { margin:0; border:0; padding:0 }
  .shade { opacity:0.2 }
  .board { padding: 1ch; background:#eee; text-align:center; position:relative }
  .piece { display:inline-block; padding:0 .5ch 0 .5ch; border: solid medium grey; border-radius:1em; margin-bottom:1ch }
  .piece:is(:last-child, :first-child) > p:nth-child(2) { display:none }
  .piece:not(:first-child, :last-child) > p:first-child:hover { border:solid medium blue }
  .piece:not(:first-child, :last-child) > p:first-child:has(+p:hover) { border:solid medium blue }
  /*.piece:before { content:'-'; display:inline-block }*/
  .cursor { position:absolute; background-color:lightpink; scale:100%; }

  /*.piece::after, .piece::before {
    font-family: 'Material Symbols Sharp';
    font-size: 1.25em;
    content: '';
    width: 11px;
    text-align: center;
    border-bottom: 2px solid var(--col-dark);
  }*/

</style></head><body>

<canvas id="animatedboxes" width="32" height="32" onclick="ConfettiSplosion.start()"></canvas>
<h1 style="display:inline-block">Sorthem™</h1>

<i>Sort the numbers and win!</i>

<div style="position:fixed; top:0; right:0">
 <b onclick="ehAddPiece()">➕</b>
 <b onclick="ehToggleAudio()">🔈</b>
 <b onclick="ehToggleAnimation()">🕺</b>
</div>

<hr/>

<div id="board" class="board">
 <div class="piece"><span onclick="ehStartButton()">START!</span></div>
</div>
<div id="winner" style="margin:1em; background:#fee; text-align:center; display:none">Winner Winner Chicken Dinner</div>


<script type="text/javascript">//<![CDATA[
"use strict";
const $ = (s)=>document.querySelector(s);
const $$ = (s)=>[...document.querySelectorAll(s)];
const log = console.log.bind(console);
const sqrt = Math.sqrt;
const abs = Math.abs;
const floor = Math.floor;
const rnd = (n)=>floor(Math.random()*n);
const min = Math.min
const max = Math.max
const dist = (a,b)=>abs(a-b);
const rgbstr = (r,g,b)=>`rgb(${r},${g},${b})`;
var animate = true;
var mute = false;
var ctx = (window.AudioContext && new window.AudioContext()) ||
          (window.webkitAudioContext && new window.webkitAudioContext());

var CreateAppendChild = function (tag, parent, text) {
  let e = parent.appendChild(document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateAfterSibling = function (tag, sibling, text) {
  let e = sibling.insertAdjacentElement('afterend', document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateBeforeSibling = function (tag, sibling, text) {
  let e = sibling.insertAdjacentElement('beforebegin', document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

/* Call fn periodically with args where args[0] specifies delay.
   Fn returns undefined (iteration stops) or an array of arguments to
   call fn with next.
*/
function setTimeoutLoop (fn, ...args) {
  const nextArgs = fn(...args);
  (undefined !== nextArgs) &&
    setTimeout(setTimeoutLoop.bind(0, fn, ...nextArgs), nextArgs[0]);
}

/* Incrementally call fn with values from..to, delay in milliseconds.
*/
function sweepMapRange(delay, from, inc, incFac, to, fn) {
  setTimeoutLoop( (delay, from, inc, incFac, to, fn)=>{
      if ((0<inc && to<from) || (inc<0 && from<to)) {
        fn(to); // Snap to endpoint
        return;
      }
      fn(from);
      return [delay, from+inc, inc*incFac, incFac, to, fn]
    }, delay, from, inc, incFac, to, fn)
}

function ehAddPiece () {
  gameBoard && gameBoard.play();
}
function ehToggleAudio () {
  event.target.innerText = (mute=!mute)?"🔇":"🔈";
}
function ehToggleAnimation () {
  event.target.innerText = (animate=!animate)?"🕺":"🧍";
}

function audioTick () {
  if (!ctx || mute) { return; }
  let osc = ctx.createOscillator();
  let now = ctx.currentTime;

  osc.frequency.value = 6000 + rnd(1000);
  osc.type = "square";

  let gain = ctx.createGain();
  gain.gain.value = 0.5

  gain.connect(ctx.destination);
  osc.connect(gain);
  osc.start(now);
  osc.stop(now+.01);
}

/* Plot random colored boxes in a canvas periodically.
*/
+function () {
  let boxCount=4, loopDelay=200;
  let canvas = $("#animatedboxes");
  let ctx = canvas.getContext('2d');
  let size = floor(canvas.width/boxCount);
  setTimeoutLoop( (delay)=>(
      ctx.fillStyle = rgbstr(rnd(256), rnd(256), rnd(256)),
      ctx.fillRect(rnd(boxCount)*size, rnd(boxCount)*size, size, size),
      [delay]
    ),
    loopDelay);
}()

////////////////////////////////////////

var gameBoard = new class {

  board = $("#board");

  pieceMoving = null;
  pieceMovingSibling = null;
  pieceMovingOrigin = {x:0, y:0};

  pieceCursor = null;
  pieceCursorOrigin = {x:0, y:0};

  slowAdjust = 0; // Used to slowly movie pice up above user's finger on mobile.

  rows = [[]];
  rowsOriginal = [[]];
  rowsYOffset = [];
  rowsHeights = [];
  rowsLeftPads = []

  pieces () {
    return [...board.children].filter( (el)=>!el.classList.contains("cursor") );
  }

  elementDetails (e) {
    const w = e.offsetWidth;
    const h = e.offsetHeight;
    const wc = floor(w/2);
    const hc = floor(h/2);
    const x = e.offsetLeft;
    const y = e.offsetTop;
    return { w:w, h:h, wc:wc, hc:hc, x:x, y:y, xc:x+wc, yc:y+hc };
  }

  delta (a, b) { return { x:b.x-a.x, y:b.y-a.y }; }

  // Extract "pointer" location from either touch or mouse event
  pointerDetails (event) {
    const isTouch = event.changedTouches;
    const touch = isTouch ? event.changedTouches.item(0) : false;
    const x = touch ? touch.clientX : event.x;
    const y = touch ? touch.clientY : event.y;
    return { x:x, y:y, isTouch }
  }

  updateWinnerMarquee (state) {
    $("#winner").style.display = state?"block":"none";
    return this;
  }

  isWinner () { return $("#winner").style.display=="block"; }

  isSolved () {
    let winner = true;
    let valueLast = -1;
    [...this.pieces()].forEach( (box)=>{
      let value = parseInt(box.innerText)||-1;
      if (value < valueLast) { winner = false; }
      valueLast = value;
    });
    return winner;
  }

  // Add new piece by cloning the first one
  addNewPiece () {
    let piece = this.pieces()[0];
    piece.insertAdjacentElement('afterend', piece.cloneNode(true));
    return this;
  }

  /* Randomize the piece values in the game board.
     Moves the smallest/largest to the ends.
  */
  resetRandomValues () {
    let min=10000, minElm;
    let max=-1, maxElm;
    const len = this.pieces().length;
    [...this.pieces()].forEach( (piece, i)=>{
      const v = 10**(len-i-2);
      piece.innerText = v==.1 ? 0 : v;
      if (v < min) { min=v; minElm=piece; }
      if (max < v) { max=v; maxElm=piece; }
    });
    this.board.firstElementChild.insertAdjacentElement('beforebegin', minElm);
    this.board.lastElementChild.insertAdjacentElement('afterend', maxElm);

    // Repeat this process if it happened to generated an already sorted arrangement.
    return this.isSolved() && this.resetRandomValues() || this;
  }

  dupRows (rows) { return rows.map((row)=>[...row]); }

  // TODO: save/reinstate existing position/left/top values.
  lockPiecesPositions () {
    [...this.pieces()]
      .map((piece)=>[piece, piece.offsetLeft+"px", piece.offsetTop+"px"])
      .forEach(([piece, left, top])=>{
         piece.style.position="absolute";
         piece.style.left = left;
         piece.style.top = top;
      });

    this.rows = []; // array of rows of pieces
    let topOffset = -1;

    // Collect the pieces into rows
    this.pieces().map((el)=>{
      if (topOffset != el.offsetTop) {
        topOffset = el.offsetTop;
        this.rows.push([]);
      }
      this.rows[this.rows.length-1].push(el);
    });

    this.rowsOriginal = this.dupRows(this.rows);
    this.rowsYOffset = this.rows.map( (row)=>row[0].offsetTop );
    this.rowsHeights = this.rows.map( (row)=>row[0].offsetHeight );
    this.rowsLeftPads = this.rows.map( (row)=>row[0].offsetLeft );
  }

  unlockPiecesPositions () {
    [...this.pieces()].forEach((piece)=>piece.style.position=null);
  }

  resetMovePieceSatate () {
    if (this.pieceMoving) {
      this.pieceMoving.classList.remove('shade');
      this.pieceMoving = null;
      this.pieceMovingSibling = null;
    }
    if (this.pieceCursor) {
      this.pieceCursor.remove();
      this.pieceCursor = null;
    }
    this.unlockPiecesPositions();
  }

  createMouseCursorFrom (el) {
    this.pieceCursor = el.cloneNode(true);
    this.pieceCursorOrigin.x = el.offsetLeft;
    this.pieceCursorOrigin.y = el.offsetTop;
    this.pieceCursor.classList.add('cursor');
    this.pieceCursor.style.left = this.pieceCursorOrigin.x + "px";
    this.pieceCursor.style.top  = this.pieceCursorOrigin.y + "px";
    el.parentElement.appendChild(this.pieceCursor); // arbitrarily place at end of board element
  }

  handlerPieceMotionBegin (piece) {
    if (this.isWinner()) { return; } // Ignore user if currenly in a winning state, new game not setup yet.

    event.preventDefault();
    event.stopPropagation();

    this.resetMovePieceSatate(); // Reset drag/drop state in case of algorithm/UX hiccup

    this.createMouseCursorFrom(piece); // The cursor becomes a copy of the piece being moved

    this.pieceMoving = piece;
    this.pieceMovingSibling = piece.nextElementSibling;
    this.pieceMoving.classList.add('shade'); // The piece being moved is re-styled
    this.pieceMovingOrigin = this.pointerDetails(event); // Keep track of pointer start position for accurate cursor movement

    // Temporarily lock pices into absolute positions.
    this.lockPiecesPositions()

    this.slowAdjust = 0;

    setTimeoutLoop((delay)=>{
      const pointer = this.pieceMovingOrigin;
      if (!pointer.isTouch) { return }
      if (this.slowAdjust < this.rowsHeights[0]/2) { ++this.slowAdjust; } else { return; }
      this.pieceCursor.style.top  = this.pieceCursorOrigin.y -this.slowAdjust + "px";
      return [delay];
    }, 20);
    return true;
  }

  handlerPieceMotionEnd () {
    this.resetMovePieceSatate();
    if (this.isSolved() && !this.isWinner()) {
      ConfettiSplosion.start();
      this.updateWinnerMarquee(true)
      setTimeout(this.play.bind(this), 2000);
    }
    return true;
  }


  handlerPieceMotion () {
    if (!this.pieceMoving) { return true; } // Skip if not in a "lifting/moving piece" state

    const pointer = this.pointerDetails(event);
    if (pointer.isTouch && this.slowAdjust < this.rowsHeights[0]/2) { ++this.slowAdjust; }
    const pointerDelta = { w:pointer.x-this.pieceMovingOrigin.x, h:pointer.y-this.pieceMovingOrigin.y-this.slowAdjust }

    // Move cursor
    this.pieceCursor.style.left = pointerDelta.w + this.pieceCursorOrigin.x + "px";
    this.pieceCursor.style.top  = pointerDelta.h + this.pieceCursorOrigin.y + "px";

    // Consider pointer's center location relative to the first child on this row.
    const cursor = this.elementDetails(this.pieceCursor);
    
    // Rearrange the pieces in the DOM, placing the lifted piece
    // in the best position relative to the mouse/cursor position.
    const cursorY = cursor.yc - this.pieceCursor.offsetHeight/2;

    const self=this; // OOP fail
//let DBOUT="";

    const cursorIsOnAnyRow = this.rowsYOffset.some((y,idx)=>dist(cursorY, y)<self.rowsHeights[idx]/2);

    (cursorIsOnAnyRow ? this.rows : this.rowsOriginal).forEach((row, rowsIdx)=>{
      let isCursorOnRow = dist(cursorY, self.rowsYOffset[rowsIdx]) < self.rowsHeights[rowsIdx]/2;
      let ptr = null;
      let widthSum = 0;
      let movingPlaced = !isCursorOnRow;
      let rowNew = []; // keep track of new piece order for this row
      row = row.map((el)=>[el, el.offsetLeft]);
      const leftPad = self.rowsLeftPads[rowsIdx];

      row.forEach( ([piece, left])=>{
//DBOUT += `${isCursorOnRow} `;
        let pieceWidth = piece.offsetWidth;

        // Always place first piece (since it is an end piece which don't move)
        if (!piece.previousElementSibling) {
//DBOUT += `}${rowsIdx}[${piece.innerText} ${widthSum} ${pieceWidth}] `;
          widthSum += pieceWidth;
          //this.board.insertBefore(piece, this.board.firstElementChild);
          ptr = piece;
          rowNew.push(ptr);
          return;
        }
        // Ignore  piece being moved.  Handled in subsequent logic in this method.
        if (cursorIsOnAnyRow && piece==this.pieceMoving) { ptr=piece; return; }

        let cursorX = cursor.xc-row[0][0].offsetLeft;
        if (!movingPlaced && (cursorX < widthSum+pieceWidth || piece==this.pieces()[this.pieces().length-1])) {
          this.pieceMoving.style.left = leftPad + widthSum +"px";
          this.pieceMoving.style.top = this.rowsYOffset[rowsIdx] + "px";
//DBOUT += `${rowsIdx}[${this.pieceMoving.innerText} ${widthSum} ${this.pieceMoving.offsetWidth}] `;
          widthSum += this.pieceMoving.offsetWidth;
          if (!ptr) {
            row[0][0].insertAdjacentElement("beforebegin", this.pieceMoving);
          } else {
            ptr.insertAdjacentElement("afterend", this.pieceMoving);
          }
          movingPlaced = true;
          ptr = this.pieceMoving;
          rowNew.push(ptr);
        }

        if (!ptr) {
          row[0][0].insertAdjacentElement("beforebegin", piece);
        } else {
          ptr.insertAdjacentElement("afterend", piece);
        }
//DBOUT += `${rowsIdx}[${piece.innerText} ${widthSum} ${pieceWidth}] `;
        rowNew.push(piece);
        piece.style.left = leftPad + widthSum + "px";
        piece.style.top = this.rowsYOffset[rowsIdx] + "px";
        widthSum += pieceWidth;
        ptr = piece;
      });

      // Update the rows state.
      this.rows[rowsIdx] = rowNew;

      // Everything was placed before the moving piece...so append it to row.
      if (!movingPlaced) {
        this.pieceMoving.style.left = leftPad + widthSum +"px";
        this.pieceMoving.style.top = this.rowsYOffset[rowsIdx] + "px";
        if (!ptr) {
          this.rows[rowsIdx+1][0].insertAdjacentElement("beforebegin", this.pieceMoving);
        } else {
          ptr.insertAdjacentElement("afterend", this.pieceMoving);
        }
//DBOUT += `[${this.pieceMoving.innerText} ${widthSum}] `;
      }

    });

//log(DBOUT);
//log(this.rows.map( (row)=>row.reduce( (r,p)=>r+" "+p.innerText, "" )));

    // Audio feed back but only if the piece moved (by way of noticing if the next sibling changed).
    if (this.pieceMoving.nextElementSibling != this.pieceMovingSibling) {
      this.pieceMovingSibling = this.pieceMoving.nextElementSibling;
      audioTick();
    }
    return true;
  }

  setupHandlerPieceMotionBegin() {
    [...this.pieces()].forEach( (piece, idx)=>{
      const isEndPiece = idx==0 || idx==this.pieces().length-1;
      piece.onmousedown = isEndPiece ? null : this.handlerPieceMotionBegin.bind(this, piece);
      piece.addEventListener("touchstart", piece.onmousedown);
    });
    return this;
  }

  setupHandlerPieceMotion() {
    document.body.onmousemove = this.handlerPieceMotion.bind(this);
    document.body.addEventListener("touchmove", document.body.onmousemove);
    return this;
  }
  setupHandlerPieceMotionEnd() {
    document.body.onmouseup = this.handlerPieceMotionEnd.bind(this);
    document.body.addEventListener("touchend", document.body.onmouseup);
    document.body.addEventListener("touchcancel", document.body.onmouseup);
    return this;
  }


  play () {
    return this
      .updateWinnerMarquee(false)
      .addNewPiece()
      .resetRandomValues()
      .setupHandlerPieceMotionBegin();
  }


  start () {
    return this
      .setupHandlerPieceMotionBegin()
      .setupHandlerPieceMotion()
      .setupHandlerPieceMotionEnd()
      // Start the board with 2 pieces
      .addNewPiece()
      .addNewPiece()
      .play();
  }

  constructor () { }

} // instance gameBoard


var ConfettiSplosion = new class {

  confetti=[];
  count = 40;

  constructor () {
    let elConfetti = CreateAppendChild("div", document.body);
    elConfetti.style.position = "fixed";
    elConfetti.style.bottom = elConfetti.style.left = 0;
    elConfetti.style.fontSize = "50%";

    this.confetti = [...Array(this.count)]
      .map((_)=>{
        const elConfetto = CreateAppendChild("p", elConfetti, " ");
        elConfetto.style.backgroundColor = `rgb(${rnd(256)},${rnd(256)},${rnd(256)})`;
        elConfetto.style.position = "absolute";
        elConfetto.style.minWidth = "1em";
        return [elConfetto, [0,0, 0,0, 0,0, rnd(360)]] ;// x,y, v,v, a,a, angle
      });
  }

  /* Calculate next position object's state:  location is incremented
     by velocity and velocity incremented by acceleration.
  */
  positionStateStep (pos) {
    return [pos[0]+pos[2], pos[1]+pos[3], pos[2]+pos[4], pos[3]+pos[5], pos[4], pos[5], pos[6]+20];
  }

  // Animate confetti fullscreen in a parabolic arc
  start () {
    if (!animate) { return this; } 
    let gw = document.body.offsetWidth;
    let gh = document.body.offsetHeight;
    // Initialize coin state: [location, velocity, acceleration]
    this.confetti.forEach((coin)=>coin[1] = [0, 0, (20+rnd(150))/5000, (300+rnd(200))/5000, 0, -.005, rnd(360)]);
    setTimeoutLoop( (delay)=>{
      let done = true;
      this.confetti.forEach( ([coin, pos], idx)=>{
        if (0 <= pos[1]) { done=false; } // Keep going as long as a coin is visible
        let posX = (floor(idx/10)%2) ? pos[0] : 1-pos[0]; // Move left or right (every other set of 10)
        // Update element position
        coin.style.left   = posX  *gw+"px";
        coin.style.bottom = pos[1]*gh+"px";
        coin.style.transform = `rotate3d(1,1,1,${pos[6]}deg)`;
        // Update position state
        this.confetti[idx][1] = this.positionStateStep(pos);
      });
      return done ? undefined : [delay];
    }, 50);
    return this
  }

} // Class ConfettiSplosion


function ehStartButton (el) {
  (el || event.target).remove();
  gameBoard.start();
}

//ehStartButton($("span"));

//]]></script></body></html><!--
-->
