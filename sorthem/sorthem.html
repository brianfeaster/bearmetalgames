<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<title>Sorthem‚Ñ¢</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="viewport" content="initial-scale=0.7"/>
<style type="text/css">
  body {background:#fff; color:#000; height:100vs;  font-family:sans-serif,arial,helvetica}
  div,p,h1 { margin:0; border:0; padding:0}
  .board { padding: 1ch; background:#eef; text-align:center; text-wrap:nowrap }
  .piece { position:relative; display:inline-block; vertical-align:top; margin-right:.5ch}
  .piece p { padding:0 1ch 0 1ch; }
  .piece > p:first-child { border: solid medium grey; border-radius:1em}
  .piece:is(:last-child, :first-child) > p:nth-child(2)  { display: none }
  .piece:not(:first-child, :last-child) > p:first-child:hover { border: solid medium blue }
  .piece:not(:first-child, :last-child) > p:first-child:has(+p:hover) { border: solid medium blue }
</style></head><body>

<canvas id="animatedboxes" width="32" height="32"></canvas>
<h1 style="display:inline-block">Sorthem‚Ñ¢</h1>
<i>Sort the numbers and win!</i>
<p style="float:right" onclick="toggleAudio()">üîà</p>
<hr/>

<div id="board" class="board">
 <div class="piece"><p><span onclick="start()">START!</span></p><p>‚òùÔ∏è</p></div>
</div>

<div id="winner" style="margin:1em; background:#fee; text-align:center; display:none">Winner Winner Chicken Dinner</div>

<div id="coins" style="position:fixed; bottom:0ch; left:0ch; font-size:300%"></div>

<script type="text/javascript">//<![CDATA[

const $ = (s)=>document.querySelector(s);
const $$ = (s)=>[...document.querySelectorAll(s)];
const log = console.log.bind(null);
const floor = Math.floor;
const rnd = (n)=>floor(Math.random()*n);
const rgbstr = (r,g,b)=>`rgb(${r},${g},${b})`;
var mute = false;
var ctx = (window.AudioContext && new window.AudioContext()) ||
          (window.webkitAudioContext && new window.webkitAudioContext());

var CreateAppendChild = function (tag, parent, text) {
  let e = parent.appendChild(document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

/* Call fn periodically with args where args[0] specifies delay.
   Fn returns undefined (iteration stops) or an array of arguments to
   call fn with next.
*/
function setTimeoutLoop (fn, ...args) {
  const nextArgs = fn(...args);
  (undefined !== nextArgs) &&
    setTimeout(setTimeoutLoop.bind(0, fn, ...nextArgs), nextArgs[0]);
}

/* Incrementally call fn with values from..to, delay in milliseconds.
*/
function sweepMapRange(delay, from, inc, incFac, to, fn) {
  audioTick();
  setTimeoutLoop( (delay, from, inc, incFac, to, fn)=>{
      if ((0<inc && to<from) || (inc<0 && from<to)) {
        fn(to); // Snap to endpoint
        return;
      }
      fn(from);
      return [delay, from+inc, inc*incFac, incFac, to, fn]
    }, delay, from, inc, incFac, to, fn)
}

function toggleAudio () {
  event.target.innerText = (mute=!mute)?"üîá":"üîà";
}

function audioTick () {
  if (!ctx || mute) { return; }
  let osc = ctx.createOscillator();
  let now = ctx.currentTime;

  osc.frequency.value = 6000 + rnd(1000);
  osc.type = "square";

  let gain = ctx.createGain();
  gain.gain.value = 0.5

  gain.connect(ctx.destination);
  osc.connect(gain);
  osc.start(now);
  osc.stop(now+.01);
}

/* Plot random colored boxes in a canvas periodically.
*/
+function () {
  let boxCount=4, loopDelay=200;
  let canvas = $("#animatedboxes");
  let ctx = canvas.getContext('2d');
  let size = floor(canvas.width/boxCount);
  setTimeoutLoop( (delay)=>(
      ctx.fillStyle = rgbstr(rnd(256), rnd(256), rnd(256)),
      ctx.fillRect(rnd(boxCount)*size, rnd(boxCount)*size, size, size),
      [delay]
    ),
    loopDelay);
}()

////////////////////////////////////////

class GameBoard {

  board = $("#board");
  pieces = board.children;
  pieceLifted = null;
  piceLiftedLoc = [0,0];

  updateWinnerMarquee (state) {
    $("#winner").style.display = state?"block":"none";
    return this;
  }

  isWinner () { return $("#winner").style.display=="block"; }

  isSolved () {
    let winner = true;
    let valueLast = -1;
    [...this.pieces].forEach( (box)=>{
      let value = parseInt(box.firstChild.innerText);
      if (value < valueLast) { winner = false; }
      valueLast = value;
    });
    return winner;
  }

  // Add new piece by cloning the first one
  addNewPiece () {
    let piece = this.pieces[0];
    piece.insertAdjacentElement('afterend', piece.cloneNode(true));
    return this;
  }

  /* Randomize the piece values in the game board.
     Moves the smallest/largest to the ends.
  */
  resetRandomValues () {
    let min=10000, minElm;
    let max=-1, maxElm;
    let v;
    [...this.pieces].forEach( (piece)=>{
      v = piece.firstChild.innerText = rnd(10000);
      if (v < min) { min=v; minElm=piece; }
      if (max < v) { max=v; maxElm=piece; }
    });
    this.board.firstElementChild.insertAdjacentElement('beforebegin', minElm);
    this.board.lastElementChild.insertAdjacentElement('afterend', maxElm);

    // Try again if already sorted
    return this.isSolved() && this.resetRandomValues() || this;
  }

  liftedStateReset () {
    this.pieceLifted =
     this.pieceLifted.style.top =
     this.pieceLifted.style.left =
     this.pieceLifted.firstChild.style.backgroundColor = null;
  }

  handlerPieceMotionBegin (piece) {
    event.preventDefault();
    event.stopPropagation();
    if (this.isWinner()) { return; }
    let touch = event.changedTouches ? event.changedTouches.item(0) : false;
    if (this.pieceLifted) { this.liftedStateReset(); }
    piece.style.zIndex = 1;
    piece.firstChild.style.backgroundColor="lightpink";
    this.pieceLifted = piece;
    this.piceLiftedLoc = [touch?touch.clientX:event.x, touch?touch.clientY:event.y];
    return true;
  }

  handlerPieceMotion () {
    if (!this.pieceLifted) { return true; } // Skip if not in a "lifting/moving piece" state

    // Extract location from either touch or mouse event
    const touch = event.changedTouches ? event.changedTouches.item(0) : false;
    let nx = (touch?touch.clientX:event.x) - this.piceLiftedLoc[0];
    let ny = (touch?touch.clientY:event.y) - this.piceLiftedLoc[1];

    // Swap elements if lifted element moved left
    const elmLeft = this.pieceLifted.previousElementSibling;
    if (nx < -elmLeft.offsetWidth/2.0 && null != elmLeft.previousElementSibling) {
      elmLeft.insertAdjacentElement("beforebegin", this.pieceLifted);
      this.piceLiftedLoc[0] -= elmLeft.offsetWidth;
      // DOM updated so recalculate lifted piece location
      nx = (touch?touch.clientX:event.x) - this.piceLiftedLoc[0];
      ny = (touch?touch.clientY:event.y) - this.piceLiftedLoc[1];
      // Animate displaced piece to lifted piece's location
      sweepMapRange(10, -this.pieceLifted.offsetWidth, 1, 1.3, 0, (v)=>elmLeft.style.left=`${v}px`);
    }
    // Swap elements if lifted element moved right
    let elmRight = this.pieceLifted.nextElementSibling;
    if (elmRight.offsetWidth/2.0 < nx && null != elmRight.nextElementSibling) {
      elmRight.insertAdjacentElement("afterend", this.pieceLifted)
      this.piceLiftedLoc[0] += elmRight.offsetWidth;
      // DOM updated so recalculate lifted piece location
      nx = (touch?touch.clientX:event.x) - this.piceLiftedLoc[0];
      ny = (touch?touch.clientY:event.y) - this.piceLiftedLoc[1];
      // Animate displaced piece to lifted piece's location
      sweepMapRange(10, this.pieceLifted.offsetWidth, -1, 1.3, 0, (v)=>elmRight.style.left=`${v}px`);
    }
    this.pieceLifted.style.left = nx+"px";
    this.pieceLifted.style.top = ny+"px";
    return true;
  }

  handlerPieceMotionEnd () {
    if (this.pieceLifted) { this.liftedStateReset(); }
    if (this.isSolved() && !this.isWinner()) {
      coinSplosion.start();
      this.updateWinnerMarquee(true)
      setTimeout(this.play.bind(this), 2000);
    }
    return true;
  }

  setupHandlerPieceMotionBegin() {
    [...this.pieces].forEach( (piece, idx)=>{
      const isEndPiece = idx==0 || idx==this.pieces.length-1;
      piece.onmousedown = isEndPiece ? null : this.handlerPieceMotionBegin.bind(this, piece);
      piece.addEventListener("touchstart", piece.onmousedown);
    });
    return this;
  }

  setupHandlerPieceMotion() {
    document.body.onmousemove = this.handlerPieceMotion.bind(this);
    document.body.addEventListener("touchmove", document.body.onmousemove);
    return this;
  }
  setupHandlerPieceMotionEnd() {
    document.body.onmouseup = this.handlerPieceMotionEnd.bind(this);
    document.body.addEventListener("touchend", document.body.onmouseup);
    document.body.addEventListener("touchcancel", document.body.onmouseup);
    return this;
  }

  constructor () {
    this.setupHandlerPieceMotion().setupHandlerPieceMotionEnd();
  }

  play () {
    this.updateWinnerMarquee(false).addNewPiece().resetRandomValues().setupHandlerPieceMotionBegin();
    return this;
  }

} // gameBoard

var coinSplosion = new class CoinSplosion {
  gw = document.defaultView.innerWidth;
  gh = document.defaultView.innerHeight;
  coins=[];

  /* Calculate next position object's state:  location is incremented
     by velocity and velocity incremented by acceleration.
  */
  positionStateStep (pos) {
    return [pos[0]+pos[2], pos[1]+pos[3], pos[2]+pos[4], pos[3]+pos[5], pos[4], pos[5]];
  }

  constructor () {
    [
     'üí∏','üí¥','üí∑','ü§ë','üí≤','üí≥','ü™ô','üí∞','üíµ','üí∂',
     'üí∏','üí¥','üí∑','ü§ë','üí≤','üí≥','ü™ô','üí∞','üíµ','üí∂',
     'üí∏','üí¥','üí∑','ü§ë','üí≤','üí≥','ü™ô','üí∞','üíµ','üí∂',
     'üí∏','üí¥','üí∑','ü§ë','üí≤','üí≥','ü™ô','üí∞','üíµ','üí∂',
     'üí∏','üí¥','üí∑','ü§ë','üí≤','üí≥','ü™ô','üí∞','üíµ','üí∂',
     'üí∏','üí¥','üí∑','ü§ë','üí≤','üí≥','ü™ô','üí∞','üíµ','üí∂',
    ].forEach( (c)=>{
      let e = CreateAppendChild("b", $("#coins"), c);
      e.style.position = "absolute";
      this.coins.push([e, [0,0, 0,0, 0,0]]);
    });
  }

  start () {
    // Initialize coin state: [location, velocity, acceleration]
    this.coins.forEach((coin)=>coin[1]= [0, 0, (20+rnd(100))/10000, (400+rnd(100))/10000, 0, -.001]);
    // Animate the coins in a parabolic arc
    setTimeoutLoop( (delay)=>{
      let done = true;
      this.coins.forEach( ([coin, pos], idx)=>{
        if (0 <= pos[1]) { done=false; } // Keep going as long as a coin is visible
        let posX = (floor(idx/10)%2) ? pos[0] : 1-pos[0]; // Move left or right
        // Update element position
        coin.style.left   = (posX*this.gw-coin.clientWidth)+"px";
        coin.style.bottom = (pos[1]*this.gh-coin.clientHeight)+"px";
        // Update position state
        this.coins[idx][1] = this.positionStateStep(pos);
      });
      return done ? undefined : [delay];
    }, 10);
  }
}

function start () {
  let eStart = event.target
  let piece = eStart.parentElement.parentElement;
  eStart.remove();
  // Start the board with 3 pieces
  piece.insertAdjacentElement('afterend', piece.cloneNode(true));
  piece.insertAdjacentElement('afterend', piece.cloneNode(true));
  (new GameBoard).play();
}

//]]></script>
</body>
</html>
