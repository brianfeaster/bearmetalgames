<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<title>Sorthem™</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="viewport" content="initial-scale=1.4"/>
<style type="text/css">
  body {background:#fff; color:#000; height:100vh; font-family:sans-serif,arial,helvetica }
  div,p,h1 { margin:0; border:0; padding:0 }
  .shade { opacity:0.2 }
  .board { padding: 1ch; background:#eee; text-align:center; position:relative }
  .piece { display:inline-flex; align-items:center; margin-bottom:1ch }
  .cursor { position:absolute }
  .cursor > .val { background-color:lightpink }
  .val {  padding:0 .5ch 0 .5ch; border:solid medium grey; border-radius:1em }
  .piece:before, .piece:after { content: ''; width: 11px; text-align: center; border-bottom: solid medium grey; }

</style></head><body>

<canvas title="confettisplosion" id="animatedboxes" width="32" height="32" onclick="ConfettiSplosion.start()"></canvas>
<h1 style="display:inline-block" onclick="window.location='??'">Sorthem™</h1>

<i>Sort the numbers and win!</i>

<div style="position:fixed; top:0; right:0">
 <b title="add new piece" onclick="ehAddPiece()">➕</b>
 <b title="toggle audio" onclick="ehToggleAudio()">🔈</b>
 <b title="toggle animation" onclick="ehToggleAnimation()">🕺</b>
</div>

<hr/>

<div id="board" class="board">
 <div class="piece"><b class="val"><span id="startbutton" onclick="sorthem.start()">START!</span></b></div>
</div>
<div id="winner" style="margin:1em; background:#fee; text-align:center; display:none">Winner Winner Chicken Dinner</div>

<script src="confettisplosion.js"></script>
<script src="../dropula/dropula.js"></script>
<script type="text/javascript">//<![CDATA[
"use strict";
const $ = (s)=>document.querySelector(s);
const $$ = (s)=>[...document.querySelectorAll(s)];
const log = console.log.bind(console);
const sqrt = Math.sqrt;
const floor = Math.floor;
const rnd = (n)=>floor(Math.random()*n);
const min = Math.min
const max = Math.max
const rgbstr = (r,g,b)=>`rgb(${r},${g},${b})`;
var animate = true;
var mute = false;
var ctx = (window.AudioContext && new window.AudioContext()) ||
          (window.webkitAudioContext && new window.webkitAudioContext());

var CreateAppendChild = function (tag, parent, text) {
  let e = parent.appendChild(document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateAfterSibling = function (tag, sibling, text) {
  let e = sibling.insertAdjacentElement('afterend', document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateBeforeSibling = function (tag, sibling, text) {
  let e = sibling.insertAdjacentElement('beforebegin', document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

/* Call fn periodically with args where args[0] specifies delay.
   Fn must return array with next call's arguments or undefined
   (to use initial args) to continue iteration.
   Iteration halts if Fn doesn't return valid args array.
*/
function setTimeoutLoop (fn, args) {
  let nextArgs = fn(...args);
  if (undefined === nextArgs) { nextArgs = args; }
  Array.isArray(nextArgs) && nextArgs.length
    && setTimeout(setTimeoutLoop.bind(0, fn, nextArgs), nextArgs[0]);
}

/* Incrementally call fn with values from..to, delay in milliseconds.
*/
function sweepMapRange(delay, from, inc, incFac, to, fn) {
  setTimeoutLoop((delay, from, inc, incFac, to, fn)=>{
      if ((0<inc[0] && to[0]<from[0]) || (inc[0]<0 && from[0]<to[0])) {
        fn(to); // Snap to endpoint
        return false;
      }
      fn(from);
      return [delay, [from[0]+inc[0], from[1]+inc[1]], [inc[0]*incFac[0], inc[1]*incFac[1]], incFac, to, fn]
    },
    [delay, from, inc, incFac, to, fn])
}

function ehAddPiece () {
  !$("span") && sorthem && sorthem.play();
}

function ehToggleAudio () {
  event.target.innerText = (mute=!mute)?"🔇":"🔈";
}

function ehToggleAnimation () {
  event.target.innerText = (animate=!animate)?"🕺":"🧍";
}

function audioTick () {
  if (!ctx || mute) { return; }
  let osc = ctx.createOscillator();
  let now = ctx.currentTime;

  osc.frequency.value = 6000 + rnd(1000);
  osc.type = "square";

  let gain = ctx.createGain();
  gain.gain.value = 0.5

  gain.connect(ctx.destination);
  osc.connect(gain);
  osc.start(now);
  osc.stop(now+.01);
}


/* Plot random colored boxes in a canvas periodically.
*/
+function () {
  const boxCount=4;
  const loopDelay=200;
  const canvas = $("#animatedboxes");
  const ctx = canvas.getContext('2d');
  const size = floor(canvas.width/boxCount);
  setTimeoutLoop(()=>{
      ctx.fillStyle = rgbstr(rnd(256), rnd(256), rnd(256));
      ctx.fillRect(rnd(boxCount)*size, rnd(boxCount)*size, size, size);
    },
    [loopDelay]);
}()


var sorthem = new class {
  board = $("#board");
  dropula = null;

  pieces () {
    return [...board.children].filter( (el)=>!el.classList.contains("cursor") );
  }

  // Add new piece by cloning the first one
  addNewPiece () {
    let piece = this.pieces()[0];
    piece.insertAdjacentElement('afterend', piece.cloneNode(true));
    return this;
  }

  isWinner () {
    return $("#winner").style.display=="block";
  }

  isSolved () {
    let winner = true;
    let valueLast = -1;
    [...this.pieces()].forEach( (box)=>{
      let value = parseInt(box.innerText)||-1;
      if (value < valueLast) { winner = false; }
      valueLast = value;
    });
    return winner;
  }

  /* Randomize the piece values in the game board.
     Moves the smallest/largest to the ends.
  */
  resetRandomValues () {
    let min=10000, minElm;
    let max=-1, maxElm;
    const len = this.pieces().length;
    [...$$(".val")].forEach( (val, i)=>{
      const v = 10**(len-i-2);
      val.innerText = v==.1 ? 0 : v;
      if (v < min) { min=v; minElm=val.parentElement; }
      if (max < v) { max=v; maxElm=val.parentElement; }
    });
    this.board.firstElementChild.insertAdjacentElement('beforebegin', minElm);
    this.board.lastElementChild.insertAdjacentElement('afterend', maxElm);

    // Repeat this process if it happened to generated an already sorted arrangement.
    return this.isSolved() && this.resetRandomValues() || this;
  }

  updateWinnerMarquee (state) {
    $("#winner").style.display = state?"block":"none";
    return this;
  }

  removeStartButton () {
    $("#startbutton").remove();
    return this;
  }

  play () {
    this
      .updateWinnerMarquee(false)
      .addNewPiece()
      .resetRandomValues();
    this
      .dropula = new Dropula(board);
    this
      .dropula.callbackMotionEnd = ()=>{
        if (this.isSolved() && !this.isWinner()) {
          this.dropula.pause = true;
          animate && ConfettiSplosion.start();
          this.updateWinnerMarquee(true)
          setTimeout(this.play.bind(this), 2000);
        }
      }
    this.dropula
      .callbackQuasiMotion = ()=>{
        audioTick();
      };
    return this;
  }

  start () {
    this
      .removeStartButton()
      .addNewPiece() // add two pieces, eventually game starts with 4
      .addNewPiece()
      .play()
  }

  constructor() { }
} // instance sorthem


/*
    const dnd_handler = dragula(dnd_containers, {
      'revertOnSpill': !this.#is_sandbox,
      'removeOnSpill': this.#is_sandbox,
      'direction': 'horizontal',
      'mirrorContainer': container,
      'copy': (el, src) => {
        return src === this.#collections_container;  // can only copy out of collections_container
      },
      'invalid': (el, hdl) => {
        return !hdl.classList.contains('handle');  // can only drag handles
      },
      'moves': (el, src, hdl, sib) => {
        return !el.classList.contains('first-item')
            && !el.classList.contains('last-item');
      },
      'accepts': (el, src, hdl, sib) => {
        if (src === this.#collections_container) {     // cannot drop into collections_container
          return false;
        }
        return sib                                     // cannot drop into last position
            && !sib.classList.contains('gu-mirror')    // cannot drop into last position
            && !sib.classList.contains('first-item');  // cannot drop into first position
      },
    });

    dnd_handler.on('drag', (el, src) => {
      this.#on_first_interaction();
      // handle shift caused by game_container::before
      el.classList.remove('transit-shift-fix');
      if (src === this.#game_container) {
        el.classList.add('transit-shift-fix');
      }
    });

    // update the number of words used after drop
    dnd_handler.on('dragend', (el) => {
      this.#num_words_used = this.#get_board_doms().length;
      this.#update_num_words_used_display();
      this.#on_guess();
    });

*/

window.onload = ()=>window.location.search&&sorthem.start(); // Immediately start if query string exists.  Sound might not work immediately.

//]]></script>
</body></html><!--
-->
