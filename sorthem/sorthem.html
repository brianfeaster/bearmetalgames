<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<title>Sorthem‚Ñ¢</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="viewport" content="initial-scale=0.7"/>
<style type="text/css">
  body {background:#fff; color:#000; font-family: sans-serif, arial, helvetica; height:100vh}
  div,p { margin:0; padding:0; border: 0 }
  h1 {margin:0; border:0; padding:0}
  hr { margin-top:0; }

  .board { padding-top: 1ch; background:#eef; text-align:center; position:relative; text-wrap:nowrap }
  .board > div   { position:relative; display:inline-block; vertical-align:top; border:solid 4px transparent}
  .board > div > p { margin:0; padding:0 1ch 0 1ch; }
  .board > div > p:nth-child(2)  { display:inline-block }
  .board div > p:first-child { border: solid 4px grey ; border-radius:1em}

  .board div.piece:not(:first-child, :last-child) > p:first-child:hover { border: solid 4px blue }
  .board div.piece:not(:first-child, :last-child) > p:first-child:has(+p:hover) { border: solid 4px blue }

  .board > div.piece:is(:last-child, :first-child) >p:nth-child(2)  { display: none }

  .winner { margin:1em; background:#fee; text-align:center; display:none }
</style></head><body>

<canvas id="animatedboxes" width="32" height="32"></canvas>
<h1 style="display:inline-block">Sorthem‚Ñ¢</h1>
<i>Sort the numbers and win!</i>
<p style="float:right" onclick="toggleAudio()">üîà</p>
<hr/>

<div id="board" class="board">
 <div class="piece"><p><span onclick="start()">START!</span></p><p>‚òùÔ∏è</p></div>
</div>

<div class="winner">Winner Winner Chicken Dinner</div>


<script type="text/javascript">//<![CDATA[

const $ = (s)=>document.querySelector(s);
const $$ = (s)=>[...document.querySelectorAll(s)];
const log = console.log.bind(null);
const floor = Math.floor;
const rnd = (n)=>floor(Math.random()*n);
const rgbstr = (r,g,b)=>`rgb(${r},${g},${b})`;
var mute = false;
var ctx = (window.AudioContext && new window.AudioContext()) ||
          (window.webkitAudioContext && new window.webkitAudioContext());

function toggleAudio () {
  event.target.innerText = (mute=!mute)?"üîá":"üîà";
}

function audioTick () {
  if (!ctx || mute) { return; }
  let osc = ctx.createOscillator();
  let now = ctx.currentTime;

  osc.frequency.value = 6000 + rnd(1000);
  osc.type = "square";

  let gain = ctx.createGain();
  gain.gain.value = 0.5

  gain.connect(ctx.destination);
  osc.connect(gain);
  osc.start(now);
  osc.stop(now+.01);
}

/* Call fn periodically with args where args[0] specifies delay.
   Fn returns undefined (iteration stops) or an array of arguments to
   call fn with next.
*/
function setTimeoutLoop (fn, ...args) {
  const nextArgs = fn(...args);
  (undefined !== nextArgs) &&
    setTimeout(setTimeoutLoop.bind(0, fn, ...nextArgs), nextArgs[0]);
}

/* Incrementally call fn with values from..to, delay in milliseconds.
*/
function sweepMapRange(delay, from, inc, incFac, to, fn) {
  audioTick();
  setTimeoutLoop( (delay, from, inc, incFac, to, fn)=>{
      if ((0<inc && to<from) || (inc<0 && from<to)) {
        fn(to); // Snap to endpoint
        return;
      }
      fn(from);
      return [delay, from+inc, inc*incFac, incFac, to, fn]
    }, delay, from, inc, incFac, to, fn)
}

/* Plot random colored boxes in a canvas periodically.
*/
+function () {
  let boxCount=4, loopDelay=200;
  let canvas = $("#animatedboxes");
  let ctx = canvas.getContext('2d');
  let size = floor(canvas.width/boxCount);
  setTimeoutLoop( (delay)=>(
      ctx.fillStyle = rgbstr(rnd(256), rnd(256), rnd(256)),
      ctx.fillRect(rnd(boxCount)*size, rnd(boxCount)*size, size, size),
      [delay]
    ),
    loopDelay);
}()

////////////////////////////////////////

class GameBoard {

  board = $("#board");
  pieces = board.children;
  pieceLifted = null;
  piceLiftedLoc = [0,0];

  updateWinnerMarquee (state) {
    $(".winner").style.display = state?"block":null;
    return this;
  }

  isWinner () { return $(".winner").style.display; }

  isSolved () {
    let winner = true;
    let valueLast = -1;
    [...this.pieces].forEach( (box)=>{
      let value = parseInt(box.firstChild.innerText);
      if (value < valueLast) { winner = false; }
      valueLast = value;
    });
    return winner;
  }

  // Add new piece by cloning the first one
  addNewPiece () {
    let piece = this.pieces[0];
    piece.insertAdjacentElement('afterend', piece.cloneNode(true));
    return this;
  }

  /* Randomize the piece values in the game board.
     Moves the smallest/largest to the ends.
  */
  resetRandomValues () {
    let min=10000, minElm;
    let max=-1, maxElm;
    let v;
    [...this.pieces].forEach( (piece)=>{
      v = piece.firstChild.innerText = rnd(10000);
      if (v < min) { min=v; minElm=piece; }
      if (max < v) { max=v; maxElm=piece; }
    });
    this.board.firstElementChild.insertAdjacentElement('beforebegin', minElm);
    this.board.lastElementChild.insertAdjacentElement('afterend', maxElm);

    // Try again if already sorted
    return this.isSolved() && this.resetRandomValues() || this;
  }

  liftedStateReset () {
    this.pieceLifted =
     this.pieceLifted.style.top =
     this.pieceLifted.style.left =
     this.pieceLifted.firstChild.style.backgroundColor = null;
  }

  handlerPieceMotionBegin (piece) {
    event.preventDefault();
    event.stopPropagation();
    let touch = event.changedTouches ? event.changedTouches.item(0) : false;
    if (this.pieceLifted) { this.liftedStateReset(); }
    piece.style.zIndex = 1;
    piece.firstChild.style.backgroundColor="lightpink";
    this.pieceLifted = piece;
    this.piceLiftedLoc = [touch?touch.clientX:event.x, touch?touch.clientY:event.y];
    return true;
  }

  handlerPieceMotion () {
    if (!this.pieceLifted) { return true; } // Skip if not in a "lifting/moving piece" state

    // Extract location from either touch or mouse event
    const touch = event.changedTouches ? event.changedTouches.item(0) : false;
    let nx = (touch?touch.clientX:event.x) - this.piceLiftedLoc[0];
    let ny = (touch?touch.clientY:event.y) - this.piceLiftedLoc[1];

    // Swap elements if lifted element moved left
    const elmLeft = this.pieceLifted.previousElementSibling;
    if (nx < -elmLeft.offsetWidth/2.0 && null != elmLeft.previousElementSibling) {
      elmLeft.insertAdjacentElement("beforebegin", this.pieceLifted);
      this.piceLiftedLoc[0] -= elmLeft.offsetWidth;
      // DOM updated so recalculate lifted piece location
      nx = (touch?touch.clientX:event.x) - this.piceLiftedLoc[0];
      ny = (touch?touch.clientY:event.y) - this.piceLiftedLoc[1];
      // Animate displaced piece to lifted piece's location
      sweepMapRange(10, -this.pieceLifted.offsetWidth, 1, 1.3, 0, (v)=>elmLeft.style.left=`${v}px`);
    }
    // Swap elements if lifted element moved right
    let elmRight = this.pieceLifted.nextElementSibling;
    if (elmRight.offsetWidth/2.0 < nx && null != elmRight.nextElementSibling) {
      elmRight.insertAdjacentElement("afterend", this.pieceLifted)
      this.piceLiftedLoc[0] += elmRight.offsetWidth;
      // DOM updated so recalculate lifted piece location
      nx = (touch?touch.clientX:event.x) - this.piceLiftedLoc[0];
      ny = (touch?touch.clientY:event.y) - this.piceLiftedLoc[1];
      // Animate displaced piece to lifted piece's location
      sweepMapRange(10, this.pieceLifted.offsetWidth, -1, 1.3, 0, (v)=>elmRight.style.left=`${v}px`);
    }
    this.pieceLifted.style.left = nx+"px";
    this.pieceLifted.style.top = ny+"px";
    return true;
  }

  handlerPieceMotionEnd () {
    if (this.pieceLifted) { this.liftedStateReset(); }
    if (this.isSolved() && !this.isWinner()) {
      this.updateWinnerMarquee(true)
      setTimeout(this.play.bind(this), 2000);
    }
    return true;
  }

  setupHandlerPieceMotionBegin() {
    [...this.pieces].forEach( (piece, idx)=>{
      const isEndPiece = idx==0 || idx==this.pieces.length-1;
      piece.onmousedown = isEndPiece ? null : this.handlerPieceMotionBegin.bind(this, piece);
      piece.addEventListener("touchstart", piece.onmousedown);
    });
    return this;
  }

  setupHandlerPieceMotion() {
    document.body.onmousemove = this.handlerPieceMotion.bind(this);
    document.body.addEventListener("touchmove", document.body.onmousemove);
    return this;
  }
  setupHandlerPieceMotionEnd() {
    document.body.onmouseup = this.handlerPieceMotionEnd.bind(this);
    document.body.addEventListener("touchend", document.body.onmouseup);
    document.body.addEventListener("touchcancel", document.body.onmouseup);
    return this;
  }

  constructor () {
    this.setupHandlerPieceMotion().setupHandlerPieceMotionEnd();
  }

  play () {
    this.updateWinnerMarquee(false).addNewPiece().resetRandomValues().setupHandlerPieceMotionBegin();
    return this;
  }

} // gameBoard

function start () {
  let eStart = event.target
  let piece = eStart.parentElement.parentElement;
  eStart.remove();
  // Start the board with 3 pieces
  piece.insertAdjacentElement('afterend', piece.cloneNode(true));
  piece.insertAdjacentElement('afterend', piece.cloneNode(true));
  (new GameBoard).play();
}

//]]></script>
</body>
</html>
